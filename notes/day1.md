# Day 1

## 概览

luajit 是一个 Lua 的即时编译器。它还包括一些扩展模块，如 Coco、DynASM 和 Lua Bitop。

luajit 的项目结构大致如下：

- src: 这个目录包含了 luajit 的核心源代码，包括虚拟机、编译器、运行时库等。
- dynasm: 这个目录包含了 DynASM 模块的源代码和文档，DynASM 是一个用于生成机器码的动态汇编器。
- lib: 这个目录包含了一些扩展库的源代码，如 Coco、Lua Bitop 等。
- etc: 这个目录包含了一些辅助工具和脚本，如 luajitrc、buildvm 等。
- test: 这个目录包含了一些测试用例和基准测试。
- doc: 这个目录包含了一些文档，如 luajit 的设计文档、Lua 5.1 参考手册等。

## `src` 目录

- lj_gc.c: 垃圾回收机制，它是内存管理的基础。
- lj_obj.c: 这个文件定义了 luajit 的对象模型，它是数据结构的基础。
- lj_str.c: 字符串操作，它是文本处理的基础。
- lj_tab.c: 表操作，它是 Lua 语言的核心特性之一。
- lj_func.c: 函数操作，它是代码执行的基础。
- lj_state.c: 状态管理，它是虚拟机的核心组件之一。
- lj_bc.c: 这个文件定义了 luajit 的字节码格式和指令集，它是编译器和解释器的桥梁。
- lj_dispatch.c: 调度器，它负责选择合适的执行模式（解释器或编译器）和优化策略（追踪或方法）。
- lj_vm.S: 虚拟机主循环，它是执行字节码的引擎。
- lj_trace.c: 追踪编译器，它是即时编译技术的核心组件之一。

## 常用的缩写

Luajit 源码中有很多缩写，它们是为了简化代码和提高可读性而使用的。以下是一些常见的缩写：

lj: LuaJIT 的简称，通常用作文件名或函数名的前缀。
gc: garbage collector 的简称，指垃圾回收机制。
obj: object 的简称，指 Lua 中的任何数据类型。
str: string 的简称，指 Lua 中的字符串类型。
tab: table 的简称，指 Lua 中的表类型。
func: function 的简称，指 Lua 中的函数类型。
bc: bytecode 的简称，指 LuaJIT 生成的字节码格式和指令集。
vm: virtual machine 的简称，指 LuaJIT 的虚拟机组件。
ir: intermediate representation 的简称，指 LuaJIT 追踪编译器使用的中间表示格式。
trace: trace 的简称，指 LuaJIT 追踪编译器生成的优化代码片段。

## 常用的数据结构

一些常用的数据结构：

- TValue: 结构体，表示一个 Lua 值，它包含了一个类型标签和一个联合体，联合体可以存储不同类型的值，如整数、浮点数、指针等。
- GCobj: 结构体，表示一个可回收的对象，它包含了一个头部和一个指向下一个对象的指针，头部中存储了对象的类型和标记信息。
- GCstr: 结构体，继承自 GCobj，表示一个字符串对象，它包含了字符串的长度和哈希值，以及字符串的内容。
- GCtab: 结构体，继承自 GCobj，表示一个表对象，它包含了表的元表、数组部分、哈希部分等信息。
- GCfunc: 结构体，继承自 GCobj，表示一个函数对象，它有两种子类型：GCfuncL 和 GCfuncC。GCfuncL 表示一个 Lua 函数，它包含了函数的原型、上值等信息。- GCfuncC：表示一个 C 函数，它包含了函数指针和 C 环境等信息。
- lua_State: 结构体，表示一个 Lua 状态机，它是虚拟机运行时的核心数据结构。它包含了当前线程、全局环境、栈、错误处理器等信息。
- BCIns: 这个类型表示一条字节码指令，它是由两个 16 位无符号整数组成的联合体。每条指令都有一个操作码和一些操作数。
- IRIns: 这个类型表示一条中间指令，它是由四个 16 位无符号整数组成的联合体。每条指令都有一个操作码、两个操作数和一些附加信息。
- SnapShot: 这个类型表示一条快照记录，它是由两个 32 位无符号整数组成的联合体。每条记录都存储了追踪编译器在某个点上栈上值和寄存器值的映射关系。

## 基本概念

标签方法: Lua 中的元表机制，它允许用户为不同类型的对象定义不同的行为，如算术运算、比较运算、索引操作等。
协程: Lua 中的轻量级线程机制，它允许用户创建多个独立的执行流，并且可以在它们之间进行切换和通信。
变长参数: Lua 中的可变参数机制，它允许用户定义和调用接受任意数量参数的函数，并且可以使用特殊符号 … 来表示和操作这些参数。
闭包: Lua 中的函数嵌套机制，它允许用户在一个函数内部定义另一个函数，并且可以访问外部函数中的局部变量。
尾调用: Lua 中的尾递归优化机制，它允许用户在一个函数最后返回另一个函数调用时，不会增加栈帧，从而节省内存和提高效率。
FFI: Luajit 中提供的外部函数接口模块，它允许用户直接调用 C 库中的函数，并且可以使用 C 的数据类型和结构体。
JIT: Luajit 中提供的即时编译技术，它可以将 Lua 代码动态地编译成机器码，并且可以根据运行时信息进行优化。

### Upvalue

pvalue 是 LuaJIT 中的一个概念，它指的是一个函数内部定义的另一个函数所引用的外部函数中的局部变量。通俗地说，就是一个函数可以访问它所在的函数中的变量，即使这个变量在它定义时已经不在作用域内了。例如：

```lua
function outer()
  local x = 10 -- 这个变量是 outer 函数中的局部变量
  function inner()
    print(x) -- 这个函数可以访问 outer 函数中的 x 变量，这个变量就是一个 upvalue
  end
  return inner -- 返回 inner 函数
end

local f = outer() -- 调用 outer 函数，得到 inner 函数
f() -- 调用 inner 函数，打印出 10
```

在这个例子中，inner 函数可以访问 outer 函数中的 x 变量，这个变量就是一个 upvalue。即使在调用 outer 函数后，x 变量已经不在作用域内了，但是因为 inner 函数还保持着对它的引用，所以它不会被回收。这样就实现了一种闭包机制，可以让函数记住它所在的环境。

Upvalue 的实现方式是使用一个结构体 GCupval 来表示一个 upvalue 对象，它包含了一个指向 upvalue 值的指针和一些标记信息。每个 Lua 函数都有一个数组来存储它所引用的所有 upvalue 对象。当函数被创建时，会根据其原型中的信息来初始化这个数组，并且将相应的 upvalue 值赋给其中的元素。当函数被调用时，会根据其栈帧中的信息来更新这些 upvalue 值。

可以在源码中找到更多细节和注释。也可以参考 src/lj_obj.h 文件来查看一些关于 upvalue 的数据结构定义和操作函数。

## 基本原理

### 执行过程

LuaJIT 解释、编译的具体过程大致如下：

- 首先，LuaJIT 会将 Lua 代码编译成字节码，这个过程和标准 Lua 相同，使用了一个递归下降的解析器和一个基于栈的虚拟机。1
- 然后，LuaJIT 会开始执行字节码，使用了一个汇编实现的快速解释器。2 这个解释器比标准 Lua 的解释器更快，因为它使用了一些优化技术，如寄存器分配、内联缓存、指令重排等。1
- 接着，LuaJIT 会监测字节码的执行频率和热度，当发现某些代码片段被频繁执行时，就会触发 JIT 编译。2 JIT 编译是指将字节码动态地转换成机器码，并缓存起来供后续使用。这样可以避免每次都重新解释字节码，从而提高性能。
- 最后，LuaJIT 会在运行时根据需要进行各种优化和转换，如常量折叠、死代码消除、循环展开、尾调用优化等。1 这些优化都是基于 SSA 形式的中间表示（IR）来进行的。

涉及到这个过程的一些主要函数有：

- lua_pcall: 这个函数是用来调用一个 Lua 函数并捕获其错误的接口函数。它会调用 lj_vm_cpcall 来设置错误处理函数，并调用 lj_vm_pcall 来执行目标函数。
- lj_vm_pcall: 这个函数是用来执行一个 Lua 函数并返回其结果或错误信息的虚拟机入口函数。它会调用 lj_dispatch_call 来设置栈帧，并调用 lj_vm_call 来开始执行。
- lj_vm_call: 这个函数是用来开始执行一个 Lua 函数或闭包的虚拟机入口函数。它会检查目标对象是否是一个 C 函数或闭包，并分别调用相应的处理函数。
- lj_BC_FUNCC: 这个函数是用来处理 C 函数或闭包的虚拟机入口函数。它会检查目标对象是否是一个 C 函数或闭包，并分别调用相应的处理函数。
- lj_BC_JFUNCV: 这个函数是用来处理 JIT 编译后的 Lua 函数或闭包的虚拟机入口函数。它会直接跳转到对应的机器码地址并开始执行。
- luaV_execute: 这个函数是用来执行字节码指令序列并返回结果或错误信息的核心解释器循环。它会根据当前指令编号和操作数类型选择相应的操作行为，并更新程序计数器和栈顶指针。
- trace_state: 这个函数是 JIT 编译器主循环中最重要也最复杂的部分之一。它负责管理跟踪状态机（TSM），即控制何时开始、停止、放弃或继续跟踪某条路径，并生成相应 IR 指令序列。

这只是一部分函数，可以在源码中找到更多细节和注释。可以参考 src/lj_dispatch.h 文件

### GC 基本原理

Luajit 的 GC 原理是基于标记-清除算法和增量收集技术的，它可以在运行时自动管理内存，回收不再使用的对象。以下是一些主要的步骤：

- Luajit 使用一个全局变量 G 作为 GC 的状态机，它包含了一些控制参数和统计信息，如 GC 模式、GC 阶段、GC 阈值、GC 计数器等。
- Luajit 使用一个双向链表 g->gc.root 作为 GC 的根集合，它包含了所有可回收的对象，如字符串、表、函数等。每个对象都有一个头部 gc->gch ，其中存储了对象的类型和标记信息。
- Luajit 使用一个枚举类型 GCState 来表示 GC 的不同阶段，如 GCSpropagate, GCSatomic, GCSsweepstring 等。每个阶段都有一个对应的函数来执行相应的操作。
- Luajit 使用一个宏 lj_gc_step 来触发 GC 的开始或继续，它会根据当前的 GC 阶段和计数器来决定是否进行下一步的操作。如果是，则调用 lj_gc_step_jit 或 lj_gc_step_interp 来执行相应的函数。
- Luajit 在标记阶段会遍历所有可达的对象，并将它们的标记设为黑色或灰色。黑色表示已经处理过的对象，灰色表示还需要进一步处理的对象。灰色对象会被放入一个队列 g->gc.gray 中等待处理。
- Luajit 在清除阶段会遍历所有不可达的对象，并将它们从链表中移除，并释放它们占用的内存。清除阶段分为多个子阶段，分别处理不同类型的对象，如字符串、表、函数等。
- Luajit 在增量收集技术中使用了一些优化策略，如延迟扫描、写屏障、弱引用等，以减少暂停时间和提高效率。

### IR

IR 是 Luajit 中的一个概念，它指的是中间表示，是一种用来描述 Lua 代码的抽象语法树。IR 的结构是基于静态单赋值形式（SSA form）的，它可以方便地进行各种优化和转换。以下是一些主要的结构：

- IRIns: 这个结构体表示一个 IR 指令，它包含了一个操作码、一个类型、两个操作数和一些标记信息。每个 IR 指令都有一个唯一的编号，用来表示其在 IR 中的位置。
- IRRef: 这个类型表示一个 IR 指令的引用，它实际上就是一个整数，用来存储 IR 指令的编号。每个 IR 指令都可以被其他 IR 指令引用，从而形成一个依赖关系。
- SnapShot: 这个结构体表示一个快照，它用来记录某个时刻的栈帧状态。每个快照都包含了一个快照编号、一个快照映射和一些标记信息。快照映射是一个数组，用来存储栈帧中每个槽位对应的 IR 引用。
- SnapEntry: 这个类型表示一个快照条目，它实际上就是一个整数，用来存储快照映射中的元素。每个快照条目都包含了一个槽位编号和一个 IR 引用。
- GCtrace: 这个结构体表示一个跟踪器，它用来记录某个循环或函数调用的执行路径。每个跟踪器都包含了一些控制参数和统计信息，如跟踪器编号、跟踪器类型、跟踪器父子关系等。
- GCtraceNo: 这个类型表示一个跟踪器编号，它实际上就是一个整数，用来存储跟踪器在全局表中的索引。
这只是一部分结构，你可以在源码中找到更多细节和注释。你也可以参考 src/lj_ir.h 文件来查看一些关于 IR 的数据结构定义和操作函数。
